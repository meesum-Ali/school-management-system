# Multi-Tenancy Guide for School Management System

This document outlines the multi-tenancy architecture implemented in the School Management System, enabling it to function as a Software-as-a-Service (SaaS) platform for multiple distinct schools.

## 1. Overview of Multi-Tenancy Model

The system employs a **shared database, shared schema** approach to multi-tenancy. This means all tenants (schools) share the same database instance and the same set of tables. Data isolation is achieved by adding a `schoolId` discriminator column to tables that store tenant-specific information.

## 2. Core Concepts

### 2.1. The `School` Entity
- A central `School` entity (`backend/src/schools/entities/school.entity.ts`) represents each tenant in the system.
- Each school has a unique `id` (UUID, referred to as `schoolId` in other entities) and other attributes like `name`, `domain` (optional, for potential subdomain identification), and `address`.
- A `SUPER_ADMIN` is responsible for creating and managing these `School` records.

### 2.2. `schoolId` for Data Isolation
- All primary data entities that belong to a specific school now have a mandatory `schoolId` foreign key column:
    - `User` (for school-specific users like teachers, school admins, students, parents, accountants)
    - `Student`
    - `ClassEntity` (classes)
    - `SubjectEntity` (subjects)
- This `schoolId` links records in these tables to a specific `School` entity.
- **Global Users/Data:** Users intended for global system administration (e.g., `SUPER_ADMIN`) will have their `schoolId` field as `NULL`. Similarly, any future data that is truly global (not tenant-specific) would not have a `schoolId`.

### 2.3. Unique Constraints
- Previously global unique constraints (e.g., username, email, student ID, class name, subject code/name) are now typically composite unique constraints based on `(field, schoolId)`. This means, for example, a username must be unique within a specific school, but different schools can have users with the same username.
- For global users (`schoolId` is NULL), uniqueness for fields like username/email is maintained globally among other global users.

## 3. User Roles and Access Control

- **`UserRole.SUPER_ADMIN`**:
    - A global role with the highest level of access.
    - Responsible for creating and managing `School` entities (onboarding new schools).
    - Can manage users across all schools (e.g., create the initial `ADMIN` for a new school).
    - Can potentially view/manage data across all tenants for administrative or support purposes (specific endpoints for this may vary).
- **`UserRole.ADMIN`**:
    - A school-specific administrator. Each `ADMIN` user is associated with a `schoolId`.
    - Their access and operations are confined to the data and resources of their assigned school. For example, an `ADMIN` of School A cannot see or manage users, students, classes, or subjects belonging to School B.
- **Other Roles (`TEACHER`, `STUDENT`, `ACCOUNTANT`, `PARENT`)**:
    - These roles are inherently scoped to a specific school because the `User` records holding these roles will have a `schoolId`.

## 4. Authentication and Tenant Context

### 4.1. Login Process
- **Frontend (`frontend/pages/login.tsx`):**
    - The login form now includes an optional `schoolIdentifier` field.
    - Users belonging to a specific school (e.g., `ADMIN`, `TEACHER`) may need to provide this identifier (e.g., their school's domain or a unique code assigned during school creation) to specify which tenant they are logging into.
    - Global users (like `SUPER_ADMIN`) log in without providing a `schoolIdentifier`.
- **Backend (`AuthService`):**
    - If `schoolIdentifier` is provided in the login request, `AuthService.validateUser` first attempts to find the corresponding `School` (e.g., by its domain).
    - It then validates the user's credentials (username, password) *within the context of that `school.id`*.
    - If no `schoolIdentifier` is provided, `AuthService.validateUser` attempts to authenticate a global user (where `User.schoolId` is `NULL`).
- **JWT Payload:**
    - Upon successful login, the JWT generated by `AuthService.login` now includes the `schoolId` of the authenticated user (if applicable; it will be `null` or undefined for global users like `SUPER_ADMIN`).
    - The payload looks like: `{ username, sub (userId), roles, schoolId }`.

### 4.2. Tenant Context in API Requests
- **Frontend (`utils/api.ts`):** The Axios API client automatically includes the JWT in the `Authorization` header for all authenticated requests.
- **Backend (`JwtStrategy`):**
    - The `JwtStrategy.validate` method decodes the JWT on incoming requests.
    - It extracts `userId`, `username`, `roles`, and `schoolId` from the payload.
    - This information is attached to the `req.user` object in NestJS controllers.
- **Controllers & Services:**
    - Controllers extract the `schoolId` from `req.user.schoolId`.
    - This `contextualSchoolId` is then passed to service methods.
    - Services use this `schoolId` in their database queries (e.g., in `WHERE` clauses) to ensure all operations are correctly scoped to the authenticated user's tenant.

## 5. Developer Guidance

- **Entities:** When creating new entities that are tenant-specific, ensure they include a non-nullable `schoolId` column and a `ManyToOne` relationship to the `School` entity. Update unique constraints to be school-specific if necessary.
- **Services:**
    - Service methods operating on tenant-specific data MUST accept `schoolId` as a parameter.
    - All TypeORM repository calls (`find`, `findOne`, `save`, `delete`, etc.) for tenant-specific entities must include a `where` clause that filters by `schoolId`.
    - Be mindful of relations: when fetching related tenant-specific data, ensure those relations are also correctly filtered by `schoolId` or that the join conditions inherently respect the tenant boundary.
- **Controllers:**
    - Extract `schoolId` from `req.user.schoolId` (populated by `JwtStrategy`).
    - Pass this `schoolId` to all relevant service methods.
    - Use role-based access control (`@Roles`) appropriately to distinguish between `SUPER_ADMIN` capabilities and school-specific `ADMIN` capabilities.
- **DTOs:**
    - Input DTOs (`Create...Dto`, `Update...Dto`) for tenant-specific resources generally should *not* include `schoolId`, as it should be derived from the user's context. An exception is when a `SUPER_ADMIN` is creating a resource for a *specific* school (e.g., `CreateUserDto` can have `schoolId` for this purpose).
    - Output DTOs (`...Dto`) should include `schoolId` if it's relevant for the client to know.

## 6. Onboarding New Schools (High-Level)

- Currently, new schools are created via an API endpoint (`POST /schools`) accessible only to `SUPER_ADMIN` users.
- The `CreateSchoolDto` allows setting the school's name, domain, address, and optionally an `adminUserId`.
- **Future Enhancement:** A more robust onboarding flow would involve:
    1. `SUPER_ADMIN` creates a `School` record.
    2. `SUPER_ADMIN` creates an initial `ADMIN` user for that school, associating them with the new `schoolId`.
    3. This school `ADMIN` can then log in (using their credentials and the school's identifier) to manage their school's users, students, etc.

This guide provides a foundational understanding of the multi-tenancy implementation. Adherence to these principles is crucial for maintaining data integrity and security across different schools.
